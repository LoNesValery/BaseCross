<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>BaseCrossドキュメント(2017年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>０．シンプルバージョンサンプル(Dx11版)</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>００１．三角形の描画(Dx11版)</h3>
　これから、<b>シンプルバージョン</b>のサンプルの説明を始めます。このサンプルは<b>SimplSample001</b>というディレクトリに含まれます。<br />
　<b>BaseCrossDx11.sln</b>というソリューションを開くと<b>Dx11版</b>が起動します。<br />
<br />
　実行結果は以下のような画面が出ます。単純な3角形の描画です。
<p>&nbsp;</p>
<img src="img/0001a.png" width="80%"/>
<p>図0001a</p>
<p>&nbsp;</p>
<br/>
<h4>Dx11版解説</h4>
　<b>BaseCrossDx11.sln</b>を開くと、<b>BaseCrossDx11</b>というメインプロジェクトがあります。この中の「Character.h/cpp」が主な記述個所になります。<br />
　表示されている三角形は<b>TriangleObjectクラス</b>です。<b>ObjectInterfaceおよびShapeInterface</b>の多重継承オブジェクトです。<br />
　ここまでは、Dx12版とほとんど一緒です。以下は、<b>TriangleObject::OnCreate()関数</b>です。
<div class="box1">
<pre>
void TriangleObject::OnCreate() {
    //頂点を作成するための配列
    vector&lt;VertexPositionColor> vertices = {
        { Vector3(0.0f, 0.5f , 0.0f),Color4(1.0f, 0.0f, 0.0f, 1.0f) },
        { Vector3(0.5f, -0.5f, 0.5f),Color4(0.0f, 1.0f, 0.0f, 1.0f) },
        { Vector3(-0.5f, -0.5f, 0.5f),Color4(0.0f, 0.0f, 1.0f, 1.0f) }
    };
    m_TriangleMesh = MeshResource::CreateMeshResource(vertices, false);
}
</pre>
</div>
　Dx12版にあった、<b>m_DrawContext</b>がないのがわかります。これはDx11は、APIがしっかりそろっていて、描画処理を直接書いてもプログラマの負担にはならないからです。ですから、<b>Dx12版のVSPSDrawContextクラス</b>のような描画のためのクラスは存在しません。<br />
　その代りOnDraw()は、少し書く内容が多いです。
<div class="box1">
<pre>
void TriangleObject::OnDraw() {
    //描画
    //デバイスの取得
    auto Dev = App::GetApp()->GetDeviceResources();
    auto pDx11Device = Dev->GetD3DDevice();
    auto pID3D11DeviceContext = Dev->GetD3DDeviceContext();
    //ステータスのポインタ
    auto RenderStatePtr = Dev->GetRenderState();

    //ストライドとオフセット
    UINT stride = sizeof(VertexPositionColor);
    UINT offset = 0;
    //頂点バッファの設定
    pID3D11DeviceContext->IASetVertexBuffers(0, 1, 
        m_TriangleMesh->GetVertexBuffer().GetAddressOf(), &stride, &offset);
    //描画方法（3角形）
    pID3D11DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    //nullテクスチャを設定
    ID3D11ShaderResourceView* pNull[1] = { 0 };
    ID3D11SamplerState* pNullSR[1] = { 0 };
    pID3D11DeviceContext->PSSetShaderResources(0, 1, pNull);
    //nullサンプラーを設定
    pID3D11DeviceContext->PSSetSamplers(0, 1, pNullSR);
    pID3D11DeviceContext->OMSetDepthStencilState(RenderStatePtr->GetDepthNone(), 0);
    //シェーダの設定
    //頂点シェーダの設定
    pID3D11DeviceContext->VSSetShader(VSPCDirect::GetPtr()->GetShader(), nullptr, 0);
    //ピクセルシェーダの設定
    pID3D11DeviceContext->PSSetShader(PSPCDirect::GetPtr()->GetShader(), nullptr, 0);
    //インプットレイアウトの設定
    pID3D11DeviceContext->IASetInputLayout(VSPCDirect::GetPtr()->GetInputLayout());

    //塗りつぶし
    pID3D11DeviceContext->OMSetBlendState(RenderStatePtr->GetOpaque(), nullptr, 0xffffffff);
    //レンダリングステート
    pID3D11DeviceContext->RSSetState(RenderStatePtr->GetCullBack());
    //描画
    pID3D11DeviceContext->Draw(3, 0);
    //後始末
    Dev->InitializeStates();

}
</pre>
</div>
　記述内容は多いですが、一つ一つが理にかなっている（というか読めばわかる）操作かと思います。<br />
　個別の解説はコメントでわかると思います。<br />
<br />
　さてこうしたうえで、シーンでのこのオブジェクトの準備と、描画呼び出しはDx12版と変わりませんので、上記説明を読んでください。<br />
<br />
<h4>まとめ</h4>
　Dx12とDx11の場合の大きな違いは、、<b>描画処理</b>になります。Dx11を使った場合は、Dx11のAPIを直接呼び出すことになります。<br />
　前述したブログも参考になると思いますので、このあたりを研究しながら自作してみるのもいいと思います。<br />
<br />
　以降、こんな感じでサンプルの解説を行っていきたいと思います。
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="00_00.html">前へ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="00_02.html">次へ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
